\appendix
\chapter{Relevant code}

\begin{verbatim}
 /** Maps are easy to use in Scala. */
object Maps {
  val colors = Map("red" -> 0xFF0000,
                   "turquoise" -> 0x00FFFF,
                   "black" -> 0x000000,
                   "orange" -> 0xFF8040,
                   "brown" -> 0x804000)
  def main(args: Array[String]) {
    for (name <- args) println(
      colors.get(name) match {
        case Some(code) =>
          name + " has code: " + code
        case None =>
          "Unknown color: " + name
      }
    )
  }
}
\end{verbatim}

\chapter{Other relevant information (demonstrations, etc.)}
\section{Horn Scunk equation to Jacobi Iteration} \label{GSDemo}
First, let us define the staring equation.
\begin{equation}
	E = (I_xu+ I_yv + I_t)^2 + \lambda(\left\Vert(\nabla u) \right\Vert_2^2 +\left\Vert(\nabla v)\right\Vert_2^2)
\end{equation}
by discretizing $\left\Vert(\nabla u) \right\Vert_2^2$ with a Laplace filter, it can be rewritten as $(\bar{u}-u)^2$. The equation then becomes:
\begin{equation}
E = (I_xu+ I_yv + I_t)^2 + \lambda((\bar{u}-u)^2+(\bar{v}-v)^2)
\end{equation}
The we apply the partial derivatives and eqaual then to 0 in order to find the minimum, as E being convex,

\begin{equation} 
\begin{split} 
\frac{\partial E}{\partial u} = I_x(I_xu+I_yv+Iy) + \lambda(\bar{u}-u) \\
\frac{\partial E}{\partial v} = I_y(I_xu+I_yv+Iy) + \lambda(\bar{v}-v)
\end{split}
\end{equation}
Now to rearrange the  terms
\begin{equation} 
\begin{split} 
(I_x^2+\lambda)u + I_y I_x v  =  -I_xI_t + \lambda \bar{u} \\
I_y I_x u+(I_y^2+\lambda)v  = -I_yI_t + \lambda \bar{v} \\
\end{split}
\end{equation}
and in matrix form , $A \boldsymbol{x} = b$:

\begin{equation}
	\begin{bmatrix}
	I_x^2+\lambda & I_y I_x \\
	I_y I_x & (I_y^2+\lambda)
	\end{bmatrix}
	\cdot
	\begin{bmatrix}
	u \\
	v
	\end{bmatrix}
	=
		\begin{bmatrix}
	-I_xI_t + \lambda \bar{u}\\
	-I_yI_t + \lambda \bar{v}
		\end{bmatrix}
\end{equation}
The equation can be solved as $\boldsymbol{x} = A^{-1}b $. First to compute 
$A$'s determinant
\begin{equation}
	\frac{1}{\lambda(\lambda+I_x^2 + I_y^2)}
\end{equation}
the equation becomes:
\begin{equation}
\begin{bmatrix}
u \\
v
\end{bmatrix}
=
\frac{1}{\lambda(\lambda+I_x^2 + I_y^2)}
\begin{bmatrix}
I_y^2+\lambda & -I_y I_x \\
-I_y I_x & (I_x^2+\lambda)
\end{bmatrix}
\cdot
\begin{bmatrix}
-I_xI_t + \lambda \bar{u}\\
-I_yI_t + \lambda \bar{v}
\end{bmatrix}
\end{equation}

from this, on can easily find $u$ and $v$ as:
\begin{equation} \label{JEq}
\begin{split}
u^{k+1} = \frac{(I_{y}^2+\lambda)\bar{u}
	-I_{x}I_{y}\bar{v}
	-I_{x}I_{t}}{I_{x}^2+I_{y}^2+ \lambda}
\\
u^{k+1} = \frac{-I_{x}I_{y}\bar{u}
	+(I_{y}^2+\lambda)\bar{v}
	-I_{y}I_{t}}{I_{x}^2+I_{y}^2+ \lambda}
\end{split}
\end{equation}


\chapter{Published papers}